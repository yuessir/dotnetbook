# 线程和线程规划

什么是线程？让我们给出一个简明的定义。本质上，线程是：

- 一种相对于其他执行代码的并行手段；
- 具有对进程所有资源的共享访问权限。

经常听到这样的看法，即.NET中的线程是完全独特的。我们的.NET线程似乎比Windows或Linux中的线程更轻量。但实际上，在.NET中的线程就是操作系统中最普通的线程（尽管线程ID被隐藏得很深，难以获取）。如果你对我在.NET多线程书籍中讲述非.NET的内容感到惊讶，我会告诉你：如果没有操作系统层面的理解，你就会忘记对代码如何以及为什么这样工作有一个良好的理解：为什么我们需要使用volatile，使用Interlocked和SpinWait。仅仅停留在普通的`lock`之外是不够的。这样做是非常不明智的：因为这样你可能会错过许多有趣的技术。因此，让我们简要地浏览一下这一层。

## 代码的并行和伪并行执行

实际上，线程是相对于其他线程模拟并行执行的工具。为什么说是模拟呢？因为线程，无论听起来多么奇怪和大胆，实际上是纯粹的程序概念，它来自操作系统。而操作系统为我们创建了这个模拟层。处理器本身对线程一无所知。处理器的任务是按顺序执行代码。因此，从处理器的角度来看，只有一个线程：顺序执行指令的线程。为了让线程出现，就需要进行模拟。"但是怎么可能呢？"，你可能会说，"我在许多商店和网站上看到有 'Intel Xeon 8核16线程' 的描述。说实话，这要么是术语上的贫乏，要么纯粹是一种营销手段。实际上，在一个大型处理器内部，这里有8个核心，每个核心由两个逻辑处理器组成，这两个逻辑处理器模拟了这个核心。这种行为在处理器具有超线程技术的情况下可用，每个核心模拟两个处理器的行为（但不是线程）。这样做是为了提高性能。

所以，如果处理器对线程一无所知，那么如何在每个核心上实现线程的并行执行呢？正如前面所说，线程是操作系统的一种工具，用于在单个处理器上同时执行多个任务。通过在非常短的时间内在不同线程之间进行非常快速的切换，从而实现了并行性。通过频繁地按顺序启动每个线程的代码并迅速切换，操作系统实现了其目标：使它们的执行在人类的感知中看起来是伪并行的，但实际上是并行的。

任何程序并不经常在处理器上连续执行操作（CPU-bound code）。更常见的情况是它与周围的世界进行交互：与各种设备（I/O bound code）交互。这包括与硬盘的工作、屏幕输出、键盘和鼠标操作以及与网络的交互。因此，为了让处理器不会闲置，当设备完成程序要求的工作时，线程可以被置于等待状态，等待操作系统的信号，以便设备完成任务。而在此期间，可以安排其他线程继续工作。这种情况的最简单示例就是调用`Console.ReadKey()`方法。

我们把这种等待状态称为**阻塞**。这意味着等待的线程被阻塞，但通常不会得到任何关于这一状态的说明。这意味着该线程不再参与线程调度。也就是说，它完全被排除在外，不会影响性能：就好像它不存在一样。

让我们来思考一下。假设您有一颗单核处理器。这是一颗非常简单的处理器。然而，为了简单起见，最初只存在一个线程。当这个线程执行时，它到达一个点，在那里它请求操作系统创建另一个线程。由于只有一个核心，处理器不知道如何在另一个核心上并行执行代码。然而，如果我们用人类的思维方式来思考，我们会发现处理器上的指令执行速度太快，以至于人类无法察觉到这一点，对吧？因此，我们可以通过交替执行第一个线程和第二个线程来划分它们的执行，这样它们将在同一个核心上依次执行：一点一点地交替执行，对用户来说看起来就像是并行工作。

如果您自己不请求操作系统中断您的代码执行，如何组织这种执行方式呢？我们不会这样写代码：

```csharp

SomeMethod1();

OS.AskToSwitchToAnotherThread();

SomeMethod2();

OS.AskToSwitchToAnotherThread();

```

其实一切都很简单到可笑的地步。要实现这样的操作，需要掌握两个知识。

知识1：处理器执行代码的状态由处理器的寄存器确定。正是这些寄存器存储着信息：处理器在指令流中的位置以及正在处理哪些数据。同时，特定的寄存器为处理器指定了关于当前虚拟内存模型的知识：各个进程（程序）之间是隔离的，每个进程都有自己的隔离内存区域。因此，要将处理器的执行从一个线程的代码“切换”到另一个线程，需要在某处保存当前线程的所有寄存器的值，即所谓的“第一个”线程，然后从另一个地方恢复另一个线程的寄存器值，之前以同样方式“暂停”。如果前后线程属于不同进程，那么隔离内存区域也会以同样方式发生变化：其位置也由寄存器确定。我们将这样的结构称为线程上下文。

知识点2：处理器有一个特殊的时钟：系统定时器。该定时器以特定频率向处理器发出脉冲，同时触发操作系统线程调度器的代码（用汇编语言编写比在.NET上编写新服务更容易）。调用是以一种方式进行的，就好像是您自己调用了线程调度器的代码，而不是操作系统（在这里有一些不太重要的细节）。这个方法的任务是保存当前线程执行位置和内存模型，即所有寄存器的值保存在线程上下文中。通过这个结构，如果将其恢复到寄存器中，您将完全恢复该线程：处理器在哪里执行代码，与哪些本地变量一起工作等等。因此，操作系统线程调度器的任务是循环执行每个线程的代码，但是逐步执行：从外部看，这看起来好像一切都在并行运行。在不同操作系统中，这种“逐步执行”的时间可能不同：从10毫秒到大约120毫秒在一般情况下。

例如，在服务器操作系统中，假设在一台服务器上运行着少量服务器软件，因此为每个线程分配长时间片：每个线程100毫秒。正因为如此，没有必要创建大量并行运行的活跃线程（CPU密集型）。这样做不会提高速度。

另一种情况是如果您的处理器有多个核心。每个核心都真正并行执行代码：这是物理核心，而不是操作系统的模拟。正因为如此，随着核心数量的增加，一切都会运行得更快。然而，当操作系统在32个核心上调度100500个线程时，它会像在单个核心的情况下一样将它们分配给线程。

正因为如此，*了解*操作系统的工作原理是无比重要的。理解为什么要开发一个由微服务组成的系统，这些微服务在同一台物理机器上运行，可能会非常痛苦、漫长，并导致失望，而不是在意识流中兴奋地编码。因为如果从一开始就获得了知识，正确的决策会更早出现，就不必重新做一部分工作了。

一个简单的结论是：由于系统定时器可以在任何时间触发并在任何时间中断线程的代码（这取决于一个核心上的线程数量），您的程序代码可能会在任何地方中断，持续时间从20毫秒到...无法确定。我知道一个糟糕的情况，当一个核心上运行了太多活跃线程时，每个线程只能每10-15秒工作100毫秒。结果是，由于代码没有自己的延迟，但操作系统中断它以让其他线程“完成工作”，导致网络超时。很难说这里的代码比单线程运行得更快。因此，另一个重要的补充是理解CPU密集型代码和I/O密集型代码的区别。

CPU密集型代码在执行时不涉及任何设备：不涉及网络、磁盘或其他任何东西。它要么是数学计算，要么处理图形或解析数据。总之，这种代码_仅_使用处理器。

I/O bound代码在执行时会访问各种设备，因此从 CPU 的角度来看，它会不断地处于阻塞状态：等待某个设备或者其他线程的信号。从操作系统的角度来看，这是一个很好的机会让另一个线程来执行代码：当前的处理器并不需要。因此，在线程被阻塞的时候，它会从调度中消失，而 CPU 在这段时间内不会花费任何时钟周期在这些线程上。这就是为什么阻塞是必要的。您可以查看 Windows 操作系统的任务管理器或者 Linux 操作系统的 `htop`。系统中可能存在数千个线程，但同时活跃的、正在工作的线程并不多。我的`htop`命令显示了几百个线程和大约 10 个活跃线程。

## 结论

总结一下可以说：
- 多线程代码不仅可以在多核系统上运行。即使是单核处理器也可以执行多线程代码。但这并不是因为它本身具备这种能力，而是因为这是操作系统的功能；
- 操作系统使用处理器的系统定时器，通过向处理器引脚提供电压（粗略地说，现在定时器已经集成在处理器中），来启动线程调度器的代码；
- 根据操作系统和其工作模式，操作系统的线程调度器会切换活动线程：切换线程上下文，其中除了其他寄存器外，还包括一对`CS:EIP`，存储当前执行指令的指针，以及`GDTR`、`LDTR`和`IDTR`寄存器，指向存储特殊表的位置，其中包括负责虚拟内存管理的树结构；
- 由于程序通常需要与硬件交互：等待连接到端口、下载数据、发送响应、等待用户输入等类似操作，因此需要多个线程来**等待**硬件的响应，这可能需要很长时间；
- 当一些线程在等待硬件时，其他线程在工作。因此，在任何时刻，活动的线程数量并不多，程序可以很活跃地运行，利用数百个线程和8个核心。
- 然而，如果线程不与硬件交互，它会使用完全分配给它的时间片。即从20毫秒到120毫秒，取决于操作系统。如果每个CPU核心的线程都使用自己的时间片，这就是CPU的100%负载。

因此：
- 使用流阻塞是一种很好的技术，可以让所有线程尽可能高效地工作；
- 代码执行可能会在任何时刻被中断。例如，在执行代码`a = b;`的中途，当`b`已经被读取，但还没有写入`a`时；
- 被中断的代码可以在任何时刻继续执行：可能是在20毫秒后，也可能是在1000毫秒后，即1秒后。这完全取决于操作系统的类型以及系统中有多少活跃线程；
- 因此不要依赖于短暂的超时。它们可能会在不经意间触发：只是因为系统被其他负载所影响；
- 正因如此，不应该让一个服务器上运行多个服务/其他软件。这会增加线程执行间隙的风险，以确保一些服务的线程与其他服务的线程能够伪并行执行代码；
- 同样，没有必要创建大量的CPU密集型线程。这样做不会让代码运行更快：这些线程将共享相同的核心。