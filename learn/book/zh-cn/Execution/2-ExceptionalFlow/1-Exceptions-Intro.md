请提供需要翻译的文本。

在我们讨论命令执行流程中各个子系统时，现在是时候谈论异常或者更确切地说是异常情况了。在继续之前，让我们稍微停下来专注于异常的定义。什么是异常情况？

异常情况是指使后续代码的执行变得完全不正确的情况。不是按照预期或设计的方式执行。将应用程序整体状态或者其部分（例如对象）的状态转变为不完整的状态。也就是说，是一些特殊的、异常的情况。

为什么确定术语很重要呢？处理术语非常重要，因为它将我们限制在框架内，使代码对外部开发人员来说更加可预测。如果不遵循术语，可能会偏离由设计者创建的概念，并且会导致许多模棱两可的情况，不仅对自己而且对他人都是如此。为了加深对这个问题的理解，让我们看一个例子：

```csharp
 struct Number
 {
     // 将字符串表示转换为数字
     public static Number Parse(string source)
     {
         // ...
         if(!parsed)
         {
             throw new ParsingException();
         }
         // ...
     }

     // 将字符串表示转换为数字
     public static bool TryParse(string source, out Number result)
     {
        // ..
        return parsed;
     }
 }
```

这个例子看起来有点奇怪：这不是没有原因的。为了展示在这段代码中出现的问题是异常的，我将其夸大了一些。首先让我们看看`Parse`方法。为什么它应该抛出异常？

- 它以字符串作为参数，以某个数字作为结果，这个数字是一个值类型。通过这个数字，我们无法确定它是由正确的计算得出的还是不正确的：它只是存在。换句话说，方法的接口无法报告问题；
- 另一方面，该方法接受一个字符串，假设该字符串已经为其准备好：没有多余的字符，字符串包含某个数字。如果不是这样，那么就会出现对方法的前提条件的问题：调用我们的方法的代码提供了不正确的数据。

因此，对于该方法来说，接收到带有不正确数据的字符串的情况是异常的：方法无法返回正确的值，但也不能返回任何东西。因此，它唯一的出路就是抛出异常。

第二个方法选项具有用于指示输入数据问题的信号通道：返回值是一个布尔值，表示方法执行的成功与否。使用异常机制来报告任何问题对于这个方法来说是没有任何理由的：所有类型的问题都可以轻松地适应返回值`false`中。

## 总体情况

处理异常情况可能看起来是一个相当基本的问题：我们所需要做的就是设置`try-catch`块并等待相应的事件发生。然而，这个问题之所以看起来基本，是因为CLR和CoreCLR团队做了大量工作，以统一CLR从各个来源传入的所有错误。为了更好地理解我们将要讨论的内容，让我们看一下下面的图表：

![](./imgs/CommonScheme.png)

在这个图表中，我们可以看到，在.NET中实际上存在两个世界：与CLR相关的一切以及在CLR之后的一切：在Windows/Linux和其他不安全的世界中出现的所有可能的错误：

- 结构化异常处理（SEH）- Windows平台处理异常的标准。在调用不安全方法并随后抛出异常时，不安全和CLR之间的异常会相互转换：从不安全到CLR，反之亦然，因为CLR可能调用不安全方法，而不安全方法可能调用CLR方法。
- 向量化异常处理（VEH）- 本质上是SEH的根源，允许在异常抛出点插入处理程序。特别用于设置`FirstChanceException`。
- COM+异常- 当问题的源头是某个COM组件时，位于COM和.NET方法之间的层应该将COM错误转换为.NET异常。
- 最后，HRESULT的包装。用于将WinAPI模型（错误代码作为返回值，返回值通过方法参数传递）转换为异常模型：对于.NET来说，与操作系统不同，异常情况是标准的。

另一方面，CLI之上是编程语言，每种语言都部分或完全提供了处理异常情况的功能。例如，直到最近，VB.NET和F#在处理异常情况方面具有更丰富的功能，提供了在C#中不存在的过滤器功能。

## 返回代码 vs. 异常

值得单独注意的是，完全可以不使用异常。永远不抛出异常，总是使用返回代码。这个想法可能看起来很奇怪：毕竟，我们都习惯了异常的存在，它们很多，几乎所有我们庞大平台的类都会抛出异常。然而，如果不回避，而是深思熟虑，我们可能会得出结论，没有异常的工作可能会更加方便和安全。

想想看：在异常情况下，代码会中断，只有堆栈上方的其他代码才能捕获这个崩溃。此外，进入`catch`块时，您可能会发现应用程序处于不一致状态（例如，如果捕获了未预期的异常，而块是按基类类型捕获的）。此外，如果逻辑使用了作为`enum`形式的错误代码，用户方法会看到错误的可能性，同时可以立即了解可能发生的错误（转到`enum`的定义）。

如果基于异常情况模型，需要在错误是行为的一部分时引入返回代码。例如，在文本解析算法中，文本中的错误是正常行为，而在处理解析后的字符串的算法中，从解析器那里得到错误可能是关键的，或者换句话说，是异常情况。

## Try-Catch-Finally块简要

`try`块创建了一个程序员期望发生关键情况的部分，从外部代码的角度来看，这些情况是正常的行为。换句话说，如果我们使用某些代码，该代码认为其内部状态不一致，并因此引发异常，那么具有更广泛视野的外部系统可以通过`catch`块捕获到的异常来规范化应用程序代码的执行。因此，*通过捕获异常，您使其在代码的这一部分上合法化*。这是我认为非常重要的观点，它证明了在任何情况下都不应该捕获所有类型的异常`try-catch(Exception ex){ ... }` *以防万一*。

这并不意味着捕获异常在思想上是不好的：我只是想说，有必要捕获您从特定代码段预期的内容，而不是更多。例如，您不能期望从`ArgumentException`继承的所有异常类型，或者获得`NullReferenceException`，因为这通常意味着问题不在调用的代码中，而在*您的*代码中。但是，期望无法打开所需文件是完全正确的。即使您对此非常有信心，也不要忘记进行检查。

第三个块——`finally`——也不需要过多介绍。该块对`try-catch`块的所有情况都起作用。除了一些相当罕见的*特殊*情况，该块总是会执行。为什么有这样的执行保证？为了清理在`try`块中分配或捕获的资源和对象组。

这个块经常在没有`catch`块的情况下使用，当我们不关心哪个错误导致算法失败时，但重要的是清理为该特定算法分配的所有资源。简单的例子：对于文件复制算法，需要：两个打开的文件和用于缓存复制的内存块。我们可以分配内存，打开一个文件，但对于第二个文件出现问题。为了将所有操作封装在一个“事务”中，我们将这三个操作放在一个`try`块中（作为一种实现方式），并在`finally`中清理资源。这个例子可能看起来很简单，但重要的是展示本质。

C#编程语言中缺少的一点是`fault`块，其本质是在发生任何错误时始终执行。也就是说，与`finally`类似，但更强大。如果有这样的功能，我们就可以像经典示例一样创建一个统一的日志记录入口：

```csharp
try {
    //...
} fault exception
{
    _logger.Warn(exception);
}
```

此外，我想在导言部分提到的是异常过滤器。对于.NET平台来说，这并不是什么新鲜事物，但对于C#开发人员来说却是新鲜事物：根据异常情况进行过滤在我们的语言中是在第六个版本中才出现的。过滤器的目的是规范化一种情况，即存在一个统一的异常类型，该类型汇总了多种错误类型。而当我们想要针对特定场景进行处理时，我们不得不捕获整个组并在捕获后进行过滤。当然，过滤后，我们可以将代码重写为：

```csharp
try {
    //...
}
catch (ParserException exception)
{
    switch(exception.ErrorCode)
    {
        case ErrorCode.MissingModifier:
            // ...
            break;
        case ErrorCode.MissingBracket:
            // ...
            break;
        default:
            throw;
    }
}
```

现在我们可以正常地重写这段代码：

```csharp
try {
    //...
}
catch (ParserException exception) when (exception.ErrorCode == ErrorCode.MissingModifier)
{
    // ...
}
catch (ParserException exception) when (exception.ErrorCode == ErrorCode.MissingBracket)
{
    // ...
}
```

这种新的写法在几个方面更好：

- 通过`when`进行过滤，我们只捕获我们想要捕获的内容，而不会捕获其他内容。这在思想上是正确的；
- 新形式的代码更易阅读。通过扫视，大脑更容易找到错误定义，因为它最初是在`catch`中寻找错误，而不是在`switch-case`中寻找；
- 更不明显但同样重要的是：预先比较发生在进入`catch`块之前。这意味着这种结构对于错过所有条件的情况会比`switch`结构更快，因为后者会重新抛出异常。

代码执行的特点是，在堆栈展开之前，过滤代码会在发生异常之前执行。这可以在没有除了普通调用之外的其他调用的情况下观察到：

```csharp
static void Main()
{
    try
    {
        Foo();
    }
    catch (Exception ex) when (Check(ex))
    {
        ;
    }
}

static void Foo()
{
    Boo();
}

static void Boo()
{
    throw new Exception("1");
}

static bool Check(Exception ex)
{
    return ex.Message == "1";
}
```

![Stack without unrolling](./imgs/StackWOutUnrolling.png)

正如您在图中看到的，堆栈跟踪不仅包含第一个调用`Main`作为异常捕获点，还包含了异常抛出点之前的整个堆栈，以及通过某些不受控制的代码再次进入`Main`。可以假设这段代码就是异常抛出的代码，它只是处于过滤和选择最终处理程序的阶段。然而，值得注意的是，_并非所有调用都允许在不展开堆栈的情况下工作_。在我谦虚的看法中，对平台的外部统一性导致对其过度信任。例如，从代码角度来看，跨域调用似乎是完全透明的。然而，方法调用的工作方式完全不同。我们将在下一部分讨论这些内容。