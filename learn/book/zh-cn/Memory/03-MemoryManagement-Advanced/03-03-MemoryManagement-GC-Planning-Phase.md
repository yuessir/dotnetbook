## 规划阶段

>{.big-quote} 课程适应过程中

接下来要谈的是规划阶段。这是所有阶段中最有趣的一个。在此过程中，会进行虚拟的GC，没有物理介入。而物理介入仅仅是在规划阶段计算结果的承诺。

在标记阶段之后，我们对于应该触发哪种类型的GC（是清扫还是收集（压缩？））没有任何明确的概念。为了理解最终的碎片化是否过高，首先，需要同时进行清扫和堆压缩，但是在虚拟模式下进行。否则，无法理解哪个过程更好。如果我们可以大致估计，那么固定机制可能会干扰这些估计并破坏GC的最终结果。在规划阶段，收集的信息同时适用于两种算法，以便尽可能快速地完成所有工作并选择最佳路径。在GC了解到，例如，压缩是最好的操作之后，它就会执行。但实际上，有两种算法。我没有听说过在SOH中两种算法都在工作的讨论。直到现在，我的理解一直是：在SOH中通过压缩堆来进行垃圾收集，而在LOH中使用的是经典的C++算法，该算法处理空闲区块。

实际上，在SOH和LOH中都运行着两种算法。

SOH。

我们根据对象的大小信息，一个接一个地进行追踪，收集自由对象的组群——即插件（plugs），以及空隙的组群——即间隙（gaps）。也就是说，当我们遍历堆时，我们可以轻松地进行迭代。在堆的最开始处放置着第一个对象。我们转到虚拟方法表，通过指针进行遍历，通过它，我们可以找到包括引用类型大小在内的各种字段。我不太明白为什么sizeof()只适用于值类型，因为要获取引用类型的sizeof()，只需简单地通过指针遍历并计算这个大小即可。只有一种情况例外——对于数组和字符串。因为对于字符串和数组，你需要计算这个sizeof()，不能简单地猜测。而对于所有其他常规类型，没有任何问题。

就这样，我们一个接一个地遍历所有对象。我们理解哪些对象被标记了，因此我们可以轻松地识别出什么是插件（被占用的块），什么是间隙（空隙）。这是非常基础的计算，因为在标记阶段我们已经做了标记。所有连续的间隙我们标记为一个单一的间隙——一个组群。所有连续的被占用区域我们标记为一个单一的被占用区域。

每个空隙的大小和位置都可以被保存。对于每个填充块，其位置和最终偏移量也可以被保存。这意味着，对于每个空隙，我们计算它的大小：例如，第一个是32字节。对于插件，我们计算偏移量，这是在压缩启动时的值。如果我们进行压缩，偏移量就是当前插件移动到的位置，向后多少字节。空隙就是空隙，这里很明显。在这个阶段，如果我们谈论两种算法 - 扫描和收集（压缩？），我们可以看到所有我们需要的信息。在扫描的情况下，我们需要空隙的大小，因为我们将形成空闲区域的列表。如果我们进行堆压缩，我们只需要偏移量。在幻灯片07:10上可以看到：这里是偏移量-32，然后32+64-96，下一个偏移量是-96+64-160。这样计算很容易，所以一切都运行得很快。为了实现这一切，使用了某种虚拟内部分配器。它遍历对象并增加这个虚拟增量，立即进行这个堆的虚拟压缩。

GC在前一个填充部分的最后几个字节中存储获得的信息。

有一个对象，最后一个引用消失了，GC过后，空隙中的信息我们不再需要，这意味着我们可以自由地破坏它 - 写入我们想要的内容，包括计算结果。如果我们有一个插件，那么我们将信息写入前一个空隙。

在幻灯片08:33上，有一些插件和空隙以及中间的某个范围。我们增加了它。结果是有三个处理器字。接下来的几个字是插件。最后三个字是空闲的。在插件前，在占用区域前，我们再次增加了这三个字节的空隙。第一个字节是空隙大小，第二个是重定位偏移量。第三个被分成两部分，我们不考虑第一部分，第二部分是我们稍后将讨论的左右偏移量。

我们计算的尺寸被放入gapsize中。而重定位偏移量则放在第二个字节中。所有这些信息，都被安排在内存块上方，并且被记录在我们的图表中。

那么什么是left和right呢？通过这两个字段，可以构建一个二叉搜索树。我们有plugs和gaps。如果像幻灯片10:30那样将它们视为一个整体，那么left/right offset就是到二叉搜索树中所需plugs的左右节点的偏移量。

二叉搜索树的构建是为了在规划阶段之后，在压缩阶段能够更改所有地址：堆被压缩，对象地址发生变化。对于所有引用了我们对象的对象，需要替换出站字段、局部变量中的地址，在所有根部——总之，所有引用了正在被压缩的组的地方。为了快速完成这一操作，因此构建了一个平衡的二叉搜索树。

由于堆可以非常巨大，因此使用了一种称为Brick Table的结构。为了避免遍历整个树，使用了一种类似于卡片桌的结构。应用程序的整个内存区域被划分为大的区域。Brick Table的单元格是对二叉搜索树根的引用，该树描述了该内存范围内的plugs和gaps。

如果在幻灯片13:00中，内存范围是从1000到2000，那么第二个Brick Table单元格正是对应这个范围。它指向中心的某个plug，该plug是其他plugs的二叉搜索树的根。

如果值为零，则该范围内没有任何数据。如果值为正，则表示某个根的地址。如果值为负，则该范围是前一个范围的延续。在搜索所需地址的过程中，我们通过除以0x1000来获取单元格编号。站在单元格上，然后查看那里的值。如果为零，则没有数据；如果大于一，则为根；如果小于零，则是指向记录了根的那个Brick Table单元格的偏移量。

固定对象。

固定对象有什么坏处呢？

让我们看看幻灯片14:34。这里有一块内存，上面有plugs（内存块），苍白的区域，而亮色的部分是一个被固定的对象。在GC（垃圾收集）期间会发生什么呢？Plug会被压缩，就这样。而被固定的部分会保持原位。如果被固定部分左侧有一块内存区域，并且存在引用，会发生什么呢？

让我们回忆一下，规划阶段都做了什么？它计算plugs和gaps（间隙）。并且在接近plug的gap区域，规划会记录gap的大小和偏移量。这里就出现了一个问题。我们有两个被占用的区域。第一个是普通的plug，第二个是被固定的。我们不能把它们当作一个整体来看，因为第一个会移动，而第二个不会。因此，它们被区分为plugs和被固定的plugs。

在这种情况下，我们可以找到解决办法。因为我们所有的线程都停止了，我们可以破坏数据，然后再恢复。被固定部分前的内存被解释为可以写入某些内容的区块。但在破坏这个区域之前，需要将数据保存在某处，以便恢复。

这个区域被保存在4字节的被固定插件队列中。这是一个恢复队列。我们保存区域，以便稍后恢复。这个区域被称为saved_pre_plug。它保存了关于信息类型和它所关联的内容的信息。之后，所有内容都被压缩，这个区域被放回原位。也就是说，这里出现了一个额外的操作。

那如果相反呢？首先是被固定的对象，然后是有引用的普通对象。对于被固定的对象来说一切都好，它可以在gap中保存自己的数据。那普通对象的数据应该存放在哪里呢？它的前面是被固定的对象。

为什么要固定（pin）？因为缓冲区进入了非托管（unmanaged）内存。如果垃圾回收（GC）在开始工作之前挂起托管（managed）线程，那么对于普通线程，它是不知道的。它不能挂起它们。而如果缓冲区进入了非托管内存，那么任何人都可以并行地从非托管代码中与之工作。那里不能写入任何东西，包括plugs&gaps的信息。在这种情况下，整个这部分被标记为固定插件（pinned plug）：即被固定的对象，以及跟随其后的对象。它们都被固定。GC之后，它们保持相同的顺序。

还有一种情况。首先是一个被固定的对象，然后是两个未被固定的对象。在第三个对象之前有第二个普通对象。也就是说，当为GC合并固定插件时，它们仍然被视为分开的。最后一个插件知道前一个对象没有被固定，可以在那里写入关于gaps和plugs的信息。但这样的部分也进入了固定插件队列（pinned plug queue）作为saved_post_plug对象。

当我们有连续几个对象，其中一个被固定时，会出现一个非常不健康的情况。这是一种常见的情况。在这种情况下，两个对象被合并。为了记录gaps和offsets，我们需要破坏前一个对象和后一个对象。而为了恢复，我们必须将这些部分放入恢复队列中。

降级（Demotion）。

有这样的概念，如提升（Promotion）和降级（Demotion）。

提升：在第零代进行了GC，之后代数增加了。降级则相反。当我们有第一代，我们进行了GC，由于某种原因它变成了第零代。

GC之后，被固定的对象留在了第零代 - 这就是降级的本质。

另一种情况：有第一代和第零代。在幻灯片21:52之后的GC，左边留下的空间很少，而在gen_0下 - 刚好合适。它们都跳到了gen_0。对此不应感到惊讶。如果发生这种情况，只需找出谁固定了对象并释放它。

在幻灯片22:56展示的另一种情况：如果左边的空间不足且没有必要再放置任何东西，对象可能会掉入第二代。对于被固定的对象，可能会发生任何事情。

LOH。

在LOH中，规划阶段只对压缩有意义，以便理解后续行动。在常规的垃圾收集场景中，我们只有sweep，没有compacting。因此，在这些情况下不存在规划阶段。Sweep不使用plug&gap，不需要规划。它只是去并列出空闲区域的列表。从这个角度来看，sweep比compacting要愉快得多。

在常规模式下，LOH不执行compacting，只有在被迫的情况下才这样做。但即使在这种情况下也没有规划。因为你请求了具体的操作，它会根据现场的所有信息构建，包括所有的偏移量。将构建偏移量，plugs&gaps，只是为了理解它是否可以仅通过常规的sweep来处理。如果可能，它就会在小对象堆中执行sweep。而在大对象堆中，不需要计算什么：它会做你所请求的。因此，那里没有规划阶段。

由于LOH专门用于存储大数据，这简化了一些问题。没有必要将对象分组到plugs中。在SOH中，这完全是出于性能考虑。如果我们有一堆32字节的对象，没有必要单独考虑它们。从GC的角度来看，应该将它们视为一个整体。因此，LOH中的每个对象都是一个plug。

在其中的对象密度要低得多，这意味着地址传输更有效 - 树的工作也更高效。移动一个大对象比移动一个插件，一组大对象更容易。为了确保在LOH中存储插件和间隙信息，会预留额外的空间。我们不能允许自己在小对象堆中为间隙大小和重定位偏移量信息预留额外空间。这会太浪费了。因为我们所有对象的地址必须按处理器字的大小对齐，即8字节或4字节，而插件和重定位偏移量信息只占用3字节，所以我们不能仅用这三个字节进行操作。我们要么使用4字节，要么使用8字节。因此，在LOH中，我们使用优化，将这些信息存储在间隙中。而在LOH中，我们可以允许自己在左侧额外存储信息，而不会在固定时覆盖之前的对象。

当在LOH中构建压缩时，我们只是在所有对象之间额外预留一些空间，以便放置偏移量。当我们手动请求压缩时，我们会计算这些偏移量，然后进行压缩。

为什么在SOH中，选择压缩而不是扫描清理。

例如，这是在OutOfMemoryException之前的最后一次GC。最后的希望是能找到一些内存。

程序员可以故意请求压缩。或者是在临时段中所有空间都被选中并且全部提交了。如果在第0代和第1代的临时段中，所有空间都被选中并且全部提交，那么就需要分配一个新的段。这在时间上是昂贵的。因此，GC尝试的第一件事就是进行压缩。

高度的代际碎片化也可能触发压缩。这是主要情况之一。如果碎片化过高，没有任何可能性在内存的空闲间隙中放置分配上下文，那么就会启动压缩。

另一个情况是进程占用了太多内存。总的来说，这是显而易见的。

让我们来看看碎片化。

这个概念相当虚拟。什么意思是“过于碎片化”？答案很简单。如果我们取一个在规划阶段收集的总碎片化（这是占用空隙的总内存量）并除以一代的大小，那么我们就会得到一个比率。在零代时，如果碎片化大小为40,000字节，碎片化比率就是50%。这是一个触发点。如果碎片化增加，那么我们就会进行堆压缩。

我们获得了新信息，如果在某个堆大小下我们有超过50%的碎片化，那么就会启动一个我们希望避免的不太愉快的压缩过程。

避免压缩过程相对简单。我们经常遇到这样的情况：当我们创建同一类型的对象时，并不是立即一个接一个地创建，而是在程序的整个生命周期中创建，知道这些对象将会一起被删除。这会导致碎片化。为了避免这种情况，我们可以，例如，创建这些对象的池。在池中，对象是一个接一个地，成组创建的。当池上的引用丢失时，它们会一起被销毁，从而创建一个统一的空隙。总的来说，我得出结论，使用池是非常好的。它们可以在许多情况下帮助我们。避免碎片化，避免进入危险区域（你从池中取出的对象是第二代）。池是一种初始化方法。同样的，还有装箱，可以通过装箱模拟或甚至装箱模拟池来解决。如果有某个方法接受object，你无法改变它并被迫进行装箱，那么可以避免这种情况。规划阶段就此结束。