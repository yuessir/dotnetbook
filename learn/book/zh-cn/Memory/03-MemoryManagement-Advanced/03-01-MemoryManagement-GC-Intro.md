## 垃圾回收简介

>{.big-quote} 课程适应过程中

接下来我们要讨论的问题是垃圾回收的简介。

GC（垃圾回收）有两种主要模式：Workstation（工作站）和Server（服务器）。这与应用程序的行为特性有关：它是服务器端的还是桌面端的。

桌面应用程序有用户界面，有其响应标准。响应标准大约是一百毫秒。如果用户点击按钮后，在一百毫秒内视觉上没有任何反应，用户会开始认为程序出现了延迟。基于这些评估，应用程序应该能够均匀快速地运行，没有在随机位置的大延迟。因此，GC更频繁地运行，以保持较小的第零代堆，它可以在已知时间内完成工作。

如果GC突然在按钮绘制期间启动，它保证会在这一百毫秒之前完成，不会让用户感觉到有任何延迟。如果是服务器工作模式，那么工作条件有所不同。服务器上通常有大量内存，而内存管理器有足够的空间进行扩展。我们知道，每个核心都会创建一对堆，在GC工作过程中较少运行，如果可能的话，原则上不运行。从而，GC在垃圾回收间隙增加了服务器的工作速度。

它很少中断。如果我们谈论ASP.NET（那里我们有请求-响应模式），那么当一个节点正在进行GC时，我们可以在另一个节点上做一些事情。现在，每种模式都有两种子模式可用：并发（Concurrent）和非并发（Non-Concurrent）。并发是一种神话般的模式。也就是说，当我们进行GC时，主要模式是所有线程都会停下来，GC完成后继续工作。当内存不被其他人改变时，改变内存是最简单的。我们可以压缩堆，将所有对象指针更改为新的值。所有这些都会发生，同时主应用程序不工作，这意味着没有风险。这是非并发的。而并发是理想的模式，当一切都在并行发生。但这是不可能的。

垃圾回收是如何进行的？如果触发了第零代的触发器，只有它会被收集。这是规则。第零代由新对象组成，因此垃圾收集的范围很短，算法将非常快速地完成。

如果触发了第一代的触发器，将会收集第零代和第一代，因为假设第一代将需要更长时间来处理。如果考虑到第零代更频繁地处理，那么很可能在第一代之后，第零代也将在不久的将来被收集，所以可以立即收集它。由于第一代更加重量级，如果加上第零代的收集，这对性能的影响不会太大。

如果我们达到了第二代，它可能达到了惊人的大小，那么更不用说，如果一起收集第一代和第零代，这对整体情况几乎没有影响。

顺序是什么？

我们有一个时间表08:43。暗色部分是一些对象。浅色部分没有对象。有一个分配上下文。假设我们有一个线程。

GC在这里做什么。

首先，他标记了目标代的对象。但这里没有链接，是时候清理垃圾了。接下来是下一个阶段：GC在垃圾收集技术之间进行选择。可能有两种技术：无压缩的扫描收集（sweep collection）和有压缩的技术。

在扫描收集中，所有不可达的零代对象被视为可用空间。所有可达对象变成了第一代。也就是说，它移动了边界。我们标记了，释放了空间，移动了代。压缩收集中，所有可达的零代对象被压缩，占据了不可达对象的空间。从幻灯片上可以看到10:38，那个位置是原来的东西，而空闲的地方在哪里。我们压缩并移动代的边界。我们不会将对象从一代复制到另一代——这太昂贵了。我们移动边界，移动指针。

只有零代的对象被标记，其他对象我们没有标记，因为这太昂贵了。零代变成了空的。这是默认行为。当代的边界移动后，可达对象移动到了第一代。对象没有标记表明它们处于哪一代。当代更换时，它们不会被复制，只是地址范围改变了。当你检查GC.GetGeneration()时，你得到的是代号。这个方法查看对象地址落在哪个地址范围内。

第一代增长了，无论是在扫描情况下还是在压缩情况下。第二代和LOH（大对象堆）没有被触及。

GC在选择垃圾收集技术时，实际上可能会发生在更高一代中分配内存的情况，如果那里有一些空闲区域的话。我们有三代，还有LOH。第一代被触发时，GC在第一代和零代上工作。然后，GC决定可以将一个对象从gen_1移动到gen_2，进一步压缩堆，这样gen_0就会变得非常大。如果出于某种原因，某个对象在收集零代垃圾时被移动到了第二代，那么不应该感到惊讶，这种情况很容易发生。

另一种情况是：段落结束了。如果常规的垃圾收集不足以为allocation context腾出空间，那么当前段就开始重新预留。这个存放堆的内存段被标记为仅限gen_2。这意味着在当前段中只会有第二代。然后它分配一个新的虚拟内存段，预留一个新的块。

当应用程序启动时，它预留了一大块内存，但那里实际上没有物理内存。开始提交。在它填充内存，尝试压缩，进一步提交的过程中，内存增长。最终，它提交完了这个大的预留块。预留用尽了。现在它需要一个新的预留块。它分配了一个新的。当有多个这样的块时，这个新块被标记为临时的。它将只容纳零代和第一代。对于所有其他的，将是第二代。当有三个段时，前两个段将用于第二代，而第三个，临时的，用于零代和第一代。当有50个这样的段时，前49个段将属于第二代，而最后一个用于零代和第一代。

在刚结束的段中可能存在第零代对象，而它变成了第二代，那么它必须将旧段中第零代的对象复制到新段的第一代中。因为所有旧段都只有第二代。而对于第零代，为线程创建了分配上下文。

让我们看看幻灯片17:42，那里可以看到所有这些是如何完成的。然后分配一个新的段，所有内容都被压缩了。再往下，就没有地方了，就会分配一个新的段。在这个新段中，有第一代和第零代，而在旧的段中只有第二代。如果有很多这样的段，但其中一个第二代段突然变得非常空闲，并且释放了很多空间，那么GC可能会做出以下决定：既然我们有了一块空闲内存，而分配一个新段的成本远高于简单的复制，那么它就简单地使用其中一个旧段作为临时段，即重新利用它。

为了让这个工作良好，这个段中的旧第二代对象需要被清除。那里不应该有第二代。

我们有三代只有第二代的情况，然后它决定，第三个只有第二代的变空了，可以在那里放置一个临时段，而不是在那里从Windows分配一个新的内存块。它将第零代转移到那里，同时第零代变成了第一代。第二代从第三段移动到第四段，后者变成了只有第二代的。第三段的剩余部分变成了第零代。进行这样的重新排序，这样会更好地工作。在旧的临时段中空间用尽，而在第三段中有空间，它们交换了角色。

垃圾收集是如何进行的？

首先，某些操作会触发垃圾回收（GC）的启动。如果我们使用的是非并发GC，那么所有受管理的线程都会暂停。调用GC的线程会启动垃圾回收过程，也就是说，GC在启动它的线程中运行。接下来，选择要清理的代（generation）。对选定的代进行标记阶段，即遍历所有对象并对它们进行标记。此外，还会检查卡表（card table），寻找非零值，并将它们视为根，标记所有从这些根出发的对象。然后是计划阶段。根据标记阶段的数据，尝试确定使用哪种垃圾回收算法 - sweep（清扫）或compact（压缩）。由于速度原因，sweep通常是首选，但如果统计数据显示compact更好，则会选择它。最终我们会发现，计划阶段实际上是关键。为了确定使用哪种算法，实际上需要同时执行两种算法。最后一个操作 - 垃圾回收 - 实际上是对前一阶段计算的承诺。接下来是最后一步 - 恢复所有线程的工作。这可以在幻灯片23:17上看到。

什么会触发GC？

原因可能有很多。尝试在SOH（Small Object Heap）中分配空间，但那里的空间已经用完。inducted - 当我们手动请求时。

lowmemory - 进程内的可用内存耗尽。

empty - 我不太确定这是什么。

alloc_loh - 相应地，LOH（Large Object Heap）的内存用完了。

oos_loh - 这是简短的说法。

等等，没有必要在这些问题上停留太久。可能的情况是SOH（Small Object Heap）的空间已经用尽。这是指我们的分配上下文用完了，而且GC（垃圾回收）需要将其扩展的阶段。当需要将上下文移动到其他地方时。在扩展段之前，我们会尝试进行压缩。因为扩展段的成本很高，我们会尝试进行垃圾回收。如果不成功，就不得不扩展段。最后，在我们尝试使用新段来存放短暂对象之前，因为新段的成本更高。我们需要尝试在当前的范围内找到一些空闲的区域，并在那里放置新对象。

对LOH（Large Object Heap）也是同样的情况。

在执行了缓慢的内存分配算法、段重组和GC之后，分配器用尽了空间。手动调用GC也可能是一个触发因素。有三种模式。第一种是GC.Collect()，调用完全的GC，在强制对LOH进行压缩时会阻塞。调用GC.Collect(int gen)是针对特定代的。这和选择代是一样的。最后一种模式是GC.Collect(int gen, GCCollectionMode mode)，这是在必要的代上调用，是阻塞的，没有强制压缩，且有必要的模式。关于手动调用GC，如果你到了这个阶段，这意味着你可能并不真正理解应用程序中发生了什么。作为hotfix，为了让一切变好，会调用GC.Collect()。

我经常听到关于调用GC.Collect()的是，这发生在使用Xamarin技术的应用程序中。那里有它的特点。在Android上，有两个GC：来自.NET和来自Java的。问题在于，所有来自Java的都实现了disposable接口。加上不理解谁应该调用dispose，那里的资源泄露非常严重。如果不习惯正确编写代码，这会时不时地让人想要调用GC.Collect()。如果你想在普通应用程序中调用GC.Collect()，那么，很可能是因为我们不太清楚内部是如何工作的。为什么算法会导致需要调用这个方法。

为了避免引起问题，我们需要查看GC的指标，绘制图表。还要观察不同代内存消耗的图表重叠、GC触发的图表以及其他图表，以理解是什么导致内存下降。你可能会发现这些图表中有些地方出现了泄漏。如果有这样的地方，就需要仔细观察并研究。一般情况下，不需要调用GC.Collect()。首先，这意味着GC会失去其统计数据。手动调用该方法后，GC可能会在你刚刚分配对象的那个线程中给你一个非8KB的allocation context，而是一个较小的，这会减慢后续的内存分配速度。这只是表面上的问题。

在这个阶段，我们大致介绍了所有步骤以及它们的工作顺序。接下来，我们将讨论具体的步骤和细节。但是，当你能看到整体画面时，这些细节才显得有价值。当前的报告是关于GC的整体情况，包括GC的工作方式和不同模式。后续的报告将是深入研究。现在我们将讨论标记、计划、垃圾收集等与GC相关的内容。最后一个关于GC的报告将是一个总结性的概述报告，提出结论。基于我们所听到的，我们可以得出哪些规则，我们的算法应该如何构建，以避免GC的不良表现。