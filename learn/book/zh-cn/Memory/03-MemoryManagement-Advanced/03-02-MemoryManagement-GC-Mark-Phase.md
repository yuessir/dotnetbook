## 标记可达对象阶段

>{.big-quote} 课程适应过程中

我们讨论了内存分配，整体概念，现在我们将详细讨论。GC的标记阶段。

在这个阶段，GC了解哪些代将被收集。我们知道GC是基于追踪的。就像在3D算法追踪中构建场景一样，我们放下一束光线，与之相交的是对象，反射到的地方是反射。GC中也是如此。我们通过对象的出站链接，并通过追踪来理解哪些对象是可达的，哪些是垃圾。

它从不同的根出发，相对于这些根遍历整个对象图。它能到达的所有地方都是好的。其余的是死区。如果考虑一个简单的场景，当我们的GC不是非并发的，那么首先是托管线程停下来，当它们停下来时，我们可以对内存做任何事情。例如，进行标记阶段。在这个阶段，对于根组中的任何地址，在对象的头部设置pin标志，如果对象被固定（pinned）。Pinning可能发生在应用程序域的句柄表中，或者来自关键字fixed。当GC在fixed中间触发时，它了解需要固定这个变量。

拥有关于对象具有指向受管理字段的外部链接的信息（这一点从虚拟方法表中得知），它遍历所有的外部链接。图的遍历是通过深度优先遍历实现的。它在内部栈中保存其状态。在此过程中，每访问一个对象，我们检查如果它已被访问过，则跳过；如果没有，则在VMT（虚拟方法表）的指针上设置一个标记，表示已访问。并且，由于我们所有在虚拟方法表中的地址都按处理器字对齐（在32位系统中它们被4整除，而在64位系统中被8整除，这样做是为了让处理器在这些地址上工作得更快），所以最低的两个位不被使用且等于零。这意味着，我们可以在那里写入一些东西，同时不破坏任何东西。最重要的是，之后不要忘记去除标记。

对象中所有指向字段的外部指针都被添加到遍历地址栈中。

首先，我们将所有根添加到栈中，然后开始遍历循环。从栈顶取出地址，前往虚拟方法表，在那里遍历有关指向受管理对象的外部链接的信息。将每个外部链接重新放回栈中，并将对象标记为已遍历。进行下一次迭代。当栈为空时 - 遍历结束。所有设置的标记在计划阶段被清除。

根。

首先，根是方法的局部变量。在这个例子中，06:36有一个局部变量path，它实际上就是一个根。我们可以在局部变量中保存对象的地址，但不能保存在其他地方。为了证明对象是可达的，我们需要遍历整个线程的栈并收集那里的所有外部局部变量。

这不应该被GC收集，可能需要很长时间。

局部变量可以存储在两个地方。

首先，线程栈是一种结构，基于此结构进行方法调用。存在一个线程，在其中运行着各种方法，这些方法相互调用。它们的局部变量与同时期但在另一个线程中被调用的同名方法的局部变量不会相互干扰。每个线程都有自己的栈。这是一个数组，在调用方法时，会分配一个特定的帧——一个包含局部变量和一些调用方法时使用的参数的区块。当调用下一个方法时，它被添加到末尾。而当方法完成执行后，它们开始从这个栈中移除。这个栈正是用来存储方法的局部变量和一些参数的地方，据我所记得，从第三个参数开始存储在栈中，而前两个参数通过寄存器传递。

由于某些方法可能需要较长时间来执行，因此GC（垃圾收集器）必须理解，在特定时刻之前不需要收集这些位置的数据。接下来需要根据变量的作用域来判断，参见幻灯片09:45。第一个是变量class1。它在整个方法的生命周期内都是可访问的。从C#语言的角度来看，它从第一个大括号开始，直到最后一个大括号结束。如果从C#语言的角度谈论变量class2，它存在于if块内，从第一个大括号开始，到最后一个大括号结束。但是有两种作用域结束的情况。一种是简化的，当作用域以某个词法块结束时；另一种是当作用域在其最后一次使用的地方结束时。

以前我认为，当人们说GC（垃圾回收器）可以在方法执行过程中直接回收一个对象，如果你停止使用它并且没有其他引用指向它时，这简直就像魔法一样。GC是如何知道代码停止使用一个变量的呢？原来，一切都很简单。在方法描述的旁边，还有一个额外的变量作用域（scope）描述。它大致看起来像是在幻灯片11:11上的样子。如果逐行查看，在第一行和第二行没有变量。在第三行，变量class1出现在作用域中。然后出现了class2，它们逐渐开始消失。这是对于部分可中断作用域而言。对于完全可中断的作用域，我们有另一种情况 - 幻灯片11:37。在某个阶段，它们都不再被使用。第七行是最后使用这两个变量的地方。之后是一个return操作，之后它们就可以不被使用了。实际上，这里会发生GC，这两个实例将被回收。但它不仅仅保存变量的值，还保存了值存储的位置，因为Intel的架构并不假设你直接与内存工作。你需要先将地址转移到寄存器中，然后基于寄存器进行一些操作。在作用域表中存储的正是存储数据的寄存器。当它达到None的情况时，意味着可以从这些特定的寄存器中回收所有内容给GC。对于完全可中断的情况，在幻灯片13:06中，不使用class1。这里情况发生了变化。这意味着在第三行和第四行中，我们使用rax寄存器来存储class1，然后在第五行，它的使用消失了。如果这里触发GC，那么class1的实例可以被自由回收。

然后，JIT（即时编译器）意识到rax不再被使用，可以再次将其重新用于另一个变量。这正是在接下来的三行中所做的，之后它同样不再被使用并被回收。

这个名为“Eager root collection”的使用表格在13:55被提及。除了局部变量由线程堆栈定义外，它们还由这个表格额外定义，实际上这给我们带来了很多问题。

具体是哪些问题呢？看看这样一段代码14:21，非常简单。我们有一个每一百毫秒触发一次的计时器，它会在屏幕上显示当前的日期和时间。它开始运行，然后我们打印“Hello”，执行GC.Collect()和ReadKey()。从C#的角度来看，计时器在整个Main中被使用。在这种情况下，行为应该是这样的：打印“Hello”，然后，在用户按下按钮之前，我们开始在屏幕上滴答显示当前时间。在第二种情况下，当计时器只在一行中使用时，调用GC.Collect()，GC应该理解，在第一行之后计时器已经不再需要了。我们最多只能看到一行，然后GC就会收集这个计时器。甚至可能根本看不到。关键是行为会有所不同。这是debug模式和release模式的行为。

也就是说，当我们在release模式下，认为所有东西都已经调试好，一切都很完美，然后在服务器上运行，却出现了这样的行为，很难理解为什么会这样。结果是，release模式和debug模式下的行为不同。这是需要记住的。而且这很容易验证。

在第17:12的幻灯片上还有另一种行为的例子：我们有一个Main函数。它创建了SomeClass类的一个实例，调用DoSomething方法并等待用户操作。接下来是SomeClass，它有一个DoSomething方法，在该方法执行过程中触发了GC（垃圾回收），执行了WriteLine操作。它还有一个终结器，在该终结器中调用了终结器的代码行。这个方法可以被内联。Main方法很短，什么也不做，因此可以被优化并提前。这样一来，message变量的作用域就会消失。变量sc的作用域要么持续到DoSomething的第二行，要么持续到Main方法的末尾。区别在于，如果DoSomething被内联，那么它对当前对象this的引用就会消失。这意味着它的使用范围也会消失。因此，在DoSomething方法执行过程中调用的GC可能会在该类的方法完成之前调用该类的终结器。这也是可能的。

首先 - 我们有这个类本身。它有一个DoSomething方法，有GC.Collect，有Console.WriteLine，并且没有使用this指针，因为这一切都是静态的，还有一个终结器。如果在DoSomething方法的执行过程中，或者即使使用了this，但GC在其最后一次使用之后触发，也可能出现在该方法完成之前调用终结器的情况。对象的引用已经不再需要了，这意味着GC可以完全自由地回收这个类的实例。这听起来很可怕，但如果这种情况发生，请不要感到惊讶。

变量的作用域。

如何扩展变量的作用域，以便在两种情况下都有计时器。最简单的扩展方式是调用GC.KeepAlive()。实际上这是一个空方法，其意义在于延长变量的使用，而不做任何事情。对象的引用被传递到某处，而JIT编译器自动将变量的作用域扩展到方法的末尾。变量在等待。

另一种根类型是 pinned locals。关键词是 fixed。有两种固定（pinning）方式。固定是一件非常糟糕的事情。我们将在规划阶段讨论这个问题。如果有可能避免固定，最好这样做。如果没有这种可能，那么需要使用关键词 fixed，它实际上不会进行真正的固定。如果将这段代码反汇编为msi，我们会注意到，这些被标记为 22:24 byte* array = list 的变量，这个list会被标记为 pinned。也就是说，我们固定了list，将其地址放入array中。但list只有在这个fixed 22:49内部触发GC时才会被固定，如果在这两个大括号之间没有触发GC，那么就不会有真正的固定。只是对GC的一个标记，如果它恰好开始遍历这个区域，就需要固定这个数组。这是一个绝佳的优化。这意味着，在Eager Roots集合中，也会额外设置一个标记，即变量被视为 pinned。不仅如此，寄存器和所有实际代码中的内存将包含外部链接的地方，也会额外设置这样的标记。如果GC在大括号内部触发，它在遍历Eager Roots集合时，会理解哪些内存区域需要被固定，并在其工作期间这样做。一旦GC完成工作并释放了线程，它就会解除这些对象的固定。

另一组根是 Finalization Roots。如果我们创建了一个终结器，并且被终结的对象进入了终结队列，那么它自然成为遍历对象的根。否则，如果这些对象还引用了其他对象，它们将被GC收集。为了避免这种情况，我们也会遍历终结化对象。

GC内部根源。为了遍历对象图，使用了卡片桌。标记表格的是老一辈的引用到年轻一辈。也就是说，卡片桌同样也是根源。这就是为什么最好将对年轻一辈的引用位置分组在一起的原因。因为整个卡片桌都是根源，所以如果卡片桌上有很多非零值，标记阶段会花费更长时间。当我们在寻找非零值时。如果找到了，那么当前代的对象就引用了一个更年轻的代。我们将这个引用视为根源，并且也进行遍历。

GC句柄根源

最后一组根源是内部根源，包括句柄表。内部根源是静态的。所有类的静态字段数组是app domain内部的引用。这里也有对句柄表的引用。它们被分成了多个桶。桶根据GC句柄的类型原则进行分组，类型可能很多。有弱引用的GC句柄，有COM式的，有固定的——无法一一列举。因此，它们都可以引用到任何地方——SOH，LOH。这个表也同时是根源表。

如果不过于深入，那就是全部了。可以得出什么结论？

首先，不应该创建太多不同的GC句柄。它们的出现在GC上创建了额外的负担：句柄结构是对象图的侧面结构。为了正确处理，GC不得不深入句柄表，遍历它，重新标记对象，以便在规划阶段正确处理这些对象。

卡片桌也有问题。总的来说，不应该创建太多的静态变量。这些是永远保持一切的地方。关于固定，我们将在后面讨论，因为在规划阶段，固定扮演了重要角色。没有这样的场景，我们仅仅因为强制而使用固定，但我们肯定会记住使用关键字fixed是必须的。那么，我们最好开始准备面试了。