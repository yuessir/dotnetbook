## 结论

>{.big-quote} 课程适应过程中

让我们谈谈结论。

首先：降低跨代联系。

问题：为了优化垃圾收集GC的速度，尽可能地使用年轻代。它试图频繁地进行这一操作，以便在几毫秒内完成。为了做到这一点，它需要关于老年代的引用信息，从卡表中获取。如果卡表为空，特别是如果bundle table为空（因为它正是覆盖了数兆字节的单元），如果我们到处都遇到零——这就是极好的信息，GC将以最快速度完成。如果在bundle table上遇到非零值，则GC会转到卡表，开始分析它，进一步深入：分析数千字节的内存，最多320个对象，以了解这些对象中的哪一个引用了更年轻的一代。因此，稀疏且无序的引用是最糟糕的结果。

其中一个解决方案是将具有联系的对象放置在年轻代中相邻的位置，以便一张卡可以负责它们。按组分配它们，根据请求提供给用户代码。如果我们这样做，它们将一起进入第二代（例如，池），卡表将为空。避免在年轻代中引用，这更加困难。

需要避免强联系。从压缩阶段算法来看，为了压缩堆，需要遍历树并检查所有引用，将它们更改为新值。这是一项艰巨的工作。同时，卡表上的引用会影响一整组对象。因此，总体的强联系可能会导致GC时的性能下降。

这里的建议很简单。首先，应该将高度关联的对象在第二代中放置在一起。这是对于卡片桌的一个引用。其次，总的来说应该避免不必要的联系。有时候，我们可能不想通过两个链接访问某个字段，而是想把这个链接放在附近。这样就会增加第三个对象的链接。而强关联意味着，在压缩时，需要遍历和修正更多这样的链接。应该减少链接的数量。同时，避免使用语法糖。它们通常会形成不可见的分配。如何看到它们呢？可以安装一个扩展，它能在代码中显示隐藏的分配。这个扩展知道哪些语言结构会创建额外的流量。如果你想优化负载较重的代码，这会大有帮助。

例如，闭包在某种程度上是有害的。它们很方便，但使用时必须非常小心：闭包开始保持链接。

如果谈到disposable，那么需要在所有公共地方调用CheckDisposed()方法。除了public方法，还包括protected方法、internal方法——所有非private的方法。最糟糕的是，你传递给某处的lambda表达式成为了一个公共方法。这一刻，它变成了一个公共方法，现在它可以从某处被调用。那里也需要放置CheckDisposed()。这样的事情可能会产生额外的联系。当你忘记了某件事，对象进入了终结状态，它通过内部链接，拖着我们应用的整个树、整个图。本应在第零代被回收的对象，不知不觉中进入了第二代。

下一个建议是监控段的使用情况。如果我们的应用程序正在密集运行，可能会出现新对象的分配导致延迟的情况。怎么做呢？可以使用工具来实现。例如PerfMon、Sysinternal Utilities、dotMemory。特别是应该通过更系统的工具，如Sysinternal，来查看段。需要检查新段的分配点是否与您的性能下降点相匹配。该怎么办呢？如果是关于LOH的话，如果其中有大量缓冲区的密集流量，那么可能应该考虑切换到使用ArrayPool。它就是为此而设计的。与其不断分配一堆本身就是重元素的数组，不如使用ArrayPool。

如果是关于SOH的话，应该确保相同生命周期的对象被分配在一起，这样可以增加触发sweep而不是collect（压缩？）的可能性。如果它们一起被释放，那么也应该一起被创建。如果我们有负载很重的代码，其中不断进行临时分配，那么最好是从池中分配，而不是通过new操作，因为后者会增加GC的负担。

另一个建议是，不要在代码的高负载部分分配内存。如果这样做，垃圾回收（GC）会选择一个不是1KB而是8KB的分配窗口。如果窗口空间不足，这会导致GC操作和已提交内存区域的扩展。大量新对象的密集流量会迫使来自其他线程的短暂对象迅速进入老年代，在那里垃圾回收的条件更差。如果我们有密集的流量，我们来不及释放旧对象，因此，原本计划在零代中存在的对象会进入第一代，在那里GC的速度更慢。当我们说“计划在零代中存在的对象”时，我们立刻意识到我们正在创建一个生命周期不超过一秒的对象。我们创建了它，填充了数据，几乎立即就释放了它。它是为在零代中的生活而设计的，越早释放它越好。怎么做呢？不保留引用。例如，你有一个包含自己逻辑的长方法。你不是按照一个接一个的动作原则来形成方法，而是按照“相似操作靠近”的原则。这样，初始化就在开始，而这些对象的使用则在底部。可能，可以把这些使用提前。方法很长，做了很多事情。而且，方法越长，GC在过程中触发的可能性就越高。如果你把这些对象的使用提前，这些对象在方法工作期间直接从堆中消失的可能性就会增加。如果过度保留这些对象，而GC触发了，这些对象就会进入第一代。

在代码的关键部分完全禁止使用闭包。在代码的关键部分完全禁止装箱。在需要创建临时对象以存储数据的地方，使用结构体。因为结构体放在栈上，不分配任何东西，可以立即释放。释放结构体只需要简单地移动SP寄存器的指针。无论你有多少局部变量，它们的释放速度都是相同的，与数量无关。更好的是使用ref struct - 这是只能在栈上的结构体。对它，JIT可以进行优化。

当字段数量超过两个时 - 通过引用传递。如果在这种情况下通过参数传递 - 会非常沉重，会发生复制。但如果通过引用传递，则只会传递指针，这是免费的。

避免在LOH中过度分配内存。在这个堆中放置数组要么导致它的碎片化，要么加重GC的负担。

解决方案。使用数组分割成子数组和封装它们的类。在一个报告中讲述了一个很棒的技巧。当大数组进入这个堆时 - 这是不好的。可以将一个大数组分割成一系列小数组，制作一个数组的数组。也就是说，一个其单元指向数组的数组。这一切都会放在SOH中。处理起来很容易。需要为数组设置正确的长度，例如2048。当我们通过索引访问时，我们不是除以2048，而是向右移动11位。这样我们可以非常快速地访问内部数组的元素，模拟连续内存块。同时，这样的数组会进入SOH，如果使用ArrayPool，它们会进入第二代，停止影响垃圾收集。

也应该控制大量使用double，以保证它们少于一千。在哪些情况下使用流栈是合理和可行的？与其使用new操作符创建类，不如使用流栈。例如，存在一些超短命的对象——那些仅在方法调用范围内存活的对象。这样的事物会产生流量，尤其是在负载较重的地方。首先，使用栈上的分配将完全减轻堆的负担。在栈上分配内存要么是创建一个局部变量，要么是使用stackalloc关键字。在我的书中有一个章节专门讨论这个操作符，名为“流栈”。这是一个C#操作符，它不是在堆上，而是在局部变量中分配内存。这个操作几乎是免费的，而且非常快。

为了学习如何正确使用这个操作符，我决定咨询作者。我打开了源代码并进行了搜索。90%的使用是在测试中。在其他地方非常罕见。特别是，我遇到了stack list和value stringbuilder。普通的stringbuilder有什么问题？我们被告知，用加号连接字符串是不好的。普通的stringbuilder做了什么？它是一个单链表，在内部有数组片段组成字符串。当我们创建字符串时，我们会附加到它上面。它按顺序填充这些片段。这意味着你可以避免字符串碎片化的问题，但并不完全。在这种情况下，仍然会创建很多东西。如何避免呢？

大多数使用simple stringbuilder和加号的情况都是用于追踪。Logger.trace()或logger.debug()。你会从各种不同的事物中形成小字符串。而value stringbuilder是一个非常好的工具，但有一个问题：它的访问修饰符是internal。但是可以绕过这个问题。这是一个栈上的stringbuilder。一个在局部变量内构建字符串，而不分配任何内存的工具。创建实例时，它等待一个span - 指向某个内存范围的指针。可以这样写：Span<T> x = stackalloc T[]。也就是说，你在局部变量中分配所需大小的内存，并将其保存在span中。然后，基于这个span创建一个value stringbuilder，在这个缓冲区内构建字符串，而不分配任何内存。唯一分配内存的情况是，如果它装不下。在其他情况下，一切都会很好。第二种情况 - 如果你的logger.info接受的不是字符串，而是span，甚至不会分配字符串。

应该尽可能使用span memory，因为这是一种避免额外分配的工具。尽早释放对象。设计为短暂存在的对象可能会进入gen_1，有时甚至进入gen_2。这导致更重的GC，运行时间更长。因此，需要尽早释放对象的引用。如果一个长期算法包含与一些分散在代码中的对象相关的代码，需要进行分组，将使用移到更近的地方。这将增加它们被GC收集的可能性。

不需要调用GC.Collect()。经常看起来，如果调用GC.Collect()，那么会修正情况。但更有用的是学习GC的工作算法，并使用dotMemory和其他诊断工具查看应用程序。这将显示最负载的部分，消除不必要的分配，不必要的流量。最重要的是，不要过度：过早的优化也可能导致代码不可读。

再给你一个建议 - 避免使用固定（pinning）。固定会带来一堆问题。垃圾回收（GC）处理固定对象就像在雷区中行走。

避免使用终结器。终结器的调用是不确定的。它可能不会被调用。未调用Dispose()会导致终结器执行，连同对象中所有外部引用以及该对象持有的其他对象一起，这些都会被转移到更老的代中，使GC变得更加复杂，导致全代GC并且从sweep切换到compacting。

需要小心地调用Dispose()。避免创建过多的线程。一般建议，线程数量应该保持在核心数的范围内。如果所有线程都在无等待地运行，那么再多也没有意义。

避免不同大小的对象频繁交互。当不同大小和生命周期的对象频繁交互时，会产生碎片化，结果就是fragmentation ratio的增加，触发collection并改变所有引用对象的地址。因此，解决方案是，如果预计会有对象交互，需要控制不必要的字段，尽量使大小接近。同时，要控制不进行字符串操作。在可能的情况下，用readonly memory替换readonly span。尽早释放引用。不必要地置零，在方法中尽可能提前使用即可。