## 清扫与收集

> {.big-quote} 课程适应过程中

我们已经考虑了几乎所有阶段，除了最后一个。这是清扫和压缩阶段。

如果在规划阶段决定使用清扫，我们必须通过回收所有未使用的区块来执行垃圾收集。当我们的分配上下文（来自不同线程）开始耗尽时，它们将占用这些空闲区块，从而避免了压缩阶段。压缩阶段需要更长时间。在这个阶段之后，我们有这样一个表01:27。我们有带有桶的世代，这些桶指向一个单链表的空闲区块。桶按大小分组。在同一个桶内，列出了大致相同大小的区块列表。我们可以请求桶提供所需大小的区块，它将根据first fit原则找到合适的桶，并通过best fit在桶内找到合适的区块。

小于对象大小的间隙被忽略。

之后，saved_pre_plug和saved_post_plugs被放置在它们的位置上。然后进行更新终结器队列的工作。接着是重构内存段。

例如，可能发生这样的情况，GC之后我们的一部分页面或段不再需要。如果可以给别人，为什么要保留它们呢？操作系统很大。如果不给出去，那么所有相邻的应用程序都会抱怨运行缓慢。确实如此：因为我们的应用程序没有释放给邻居的内存。

LOH上的清扫工作方式不同。它不使用规划，而是遍历堆。将空闲区块与相邻的合并为一个。释放的区块被添加到空闲区块列表中。

对我来说，一个启示是，两个堆中的机制是相同的。只是在一个堆中，它们有不同的优先级。在LOH中，压缩的优先级如此之低，以至于部分算法被直接禁用。但总的来说，SOH和LOH使用相同的算法。

压缩。

如果需要，将创建一个新的临时段。如果规划阶段决定，压缩后为gen_0留出的空间不足，我们就创建一个新段。替换所有的引用为正确的引用。为此，我们有关于gaps&plugs的信息，通过它们可以轻松计算出所有的偏移量。在压缩之前，我们必须更换所有的引用。在收集gen_0时，我们会检查它和老一代的卡片桌。完成这些后，我们开始在压缩阶段更改引用，直到压缩本身，以免丢失有关gaps和偏移量的信息。扫描所有位置，进行替换。首先是栈上的引用，包括所有的局部变量和通过栈传递的方法参数，以及eager roots collection。然后是通过卡片桌获得的对象字段上的引用。接着是SOH和LOH对象字段上的引用，这些是在遍历图阶段获得的。还有pre和post plugs上的引用，因为在保存时可能也会有引用。Pinned plugs队列。位于finalization queue中的对象字段上的引用。句柄表上的引用。

我们必须完成这六个步骤。结论是，图的连接性越强，这一步骤的执行时间就越长。需要非常小心地遍历这一切，以避免在同一内存区域内错过缓存。

接下来是将对象复制到它们的新位置。在我们更改了所有地址之后，就进行实际的压缩阶段。从gaps的最后几个字节中取出偏移量值，并将所有存活的对象移动到该偏移量上，以压缩堆。当然，除了被固定的对象和在它们之后放置的对象之外。

之后，恢复所有pre和post plugs区域，并修正世代位置（GC后，第零代变为第一代，第一代变为第二代，并且第零代移动，以便可以进一步分配内存）。

之后，删除并解除提交完全释放的段下的内存。

在每个被固定的对象前都会形成一个空闲区域。这个区域需要被保留下来，以便于之后进行内存分配。也就是说，对象被固定了。它的左侧是已占用的空间。而在已占用的空间和被固定对象之间是空闲区域。为了之后能够重新使用这些空闲区域，它们被保存在一个空闲区域列表中。为了做到这一点，需要确保有一个合适的桶（bucket），或者创建一个新的桶，然后从那里链接到一个单链表，该链表包含了特定大小的已占用区域。

因此，sweep（清扫）的任务就是在空闲区域上创建一个单链表。压缩则需要更长的时间。为了让sweep操作生效，需要对生命周期相同的对象进行分组。这是我们能做的最大限度。

为了不干扰GC（垃圾回收），我们不使用GCHandle bind。只要可能，我们仅使用fixed。在这种情况下，我们可以避免固定，因为fixed只是提醒GC，如果它到了这里，就需要进行固定。